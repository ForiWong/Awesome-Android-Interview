tcp握手为什么是三次？两次或者四次不可以吗？
	通俗的说法:为了确认对方都有接收和发送数据的能力，
			   A发送 -- B接收 （B确认了A有发送能力）
			   B发送 -- A接收 （A确认了B有接收和发送的能力）
			   A发送 -- B接收 （B确认了A有接收能力）
			        【完毕】
	专业术语的描述是：三次握手是对[两军问题]的一个折衷解决方案，红军想告诉蓝军明天下午一起对敌开火，
					  那么红军会派信使1号跑过去告诉蓝军，蓝军收到消息再派信使2号告诉红军收到，注意，
					  这时蓝军并不知道红军是否收到蓝军的回复。因此需要红军收到回复再派信使3号告诉蓝
					  军收到回复，而此时红军也不知道蓝军是否收到回复，因此蓝军收到信使3号的消息再派
					  信使4号…可以看到，由于信息有可能丢失，为了保证信息传达的确定性，我们需要进行很
					  多次传递。互相通信的次数越多，那么这个信息传递到的概率就越大。理论上无论多少次
					  都达不到100%可靠性，3次能很快地把概率提到一个能接受的范围。
					【完毕】
	总结：这个问题的实质是在不可靠的信道上实现可靠的传输，三次通信是理论上的最小值. 所以三次握手不是
	TCP本身的要求, 而是为了满足"在不可靠信道上可靠地传输信息"这一需求所导致的。
					【完毕】
	注：谢希仁著《计算机网络》第四版中讲三次握手的目的是“为了防止已失效的连接请求报文段突然又传送到了
	服务端，因而产生错误”。--  例子是这样子的：“已失效的连接请求报文段”的产生在这样一种情况下：
		client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接
		释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报
		文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连
		接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出
		建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接
		已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办
		法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到
		确认，就知道client并没有要求建立连接。”
					【完毕】
tcp挥手为什么是四次？
	四次握手就是要客户端和服务端共发送四次用以确认链接的断开。tcp是全双工的，所以两端需要分别断开各自
	的链接。
	通俗的说法：A:“喂，我不说了。”A->FIN_WAIT1
			    B:“我知道了。等下，上一句还没说完。Balabala…..”B->CLOSE_WAIT | A->FIN_WAIT2
				B:”好了，说完了，我也不说了。”B->LAST_ACK
				A:”我知道了。”A->TIME_WAIT | B->CLOSED，A等待2MSL,
				保证B收到了消息,否则重说一次”我知道了”,A->CLOSED
				    【完毕】
			   （即A--->B Fin, 
			       B--->A ACK, 
				   B--->A Fin, 
				   A--->B ACK）
				A--->B Fin, B--->A ACK ，A属于主动关闭方，收到B的ACK后，A到B的方向连接关闭，即half shutown ，
				这时A不能再发送数据了。
				这种状态下B还是可以单向发送数据的，B的数据发送完毕，也做关闭动作了：B--->A Fin, A--->B ACK
				B收到ACK，关闭连接。但是A无法知道ACK是否已经到达B，于是开始等待？等待什么呢？假如ACK
				没有到达B，B会为FIN这个消息超时重传 timeout retransmit ，那如果A等待时间足够，又收到FIN消息，
				说明ACK没有到达B，于是再发送ACK，直到在足够的时间内没有收到FIN，说明ACK成功到达。这个等待时
				间至少是：B的timeout + FIN的传输时间，为了保证可靠，采用更加保守的等待时间2MSL。
				MSL，Maximum Segment Life，这是TCP 对TCP Segment 生存时间的限制。TTL， Time To Live ，IP对
				IP Datagram 生存时间的限制，255 秒，所以 MSL一般 = TTL = 255秒，A发出ACK，等待ACK到达对方的
				超时时间 MSL，等待FIN的超时重传，也是MSL，所以如果2MSL时间内没有收到FIN，说明对方安全收到FIN。
					【完毕】
	专业术语的描述是：
				假定TCP client端主动发起断开连接，
				1 client端的application 接受用户断开TCP连接请求，这个是由用户触发的请求，以消息的方式
				  到达client TCP，client TCP 发送 FIN=1 给 server 端 TCP
				2 server 端TCP 接收到FIN=1 断开连接请求，需要咨询 application的意见，需要发消息给application，
				  消息内容：对方要断开连接，请问您老人家还有数据要发送吗？如果有数据请告知，没有数据
				  也请告知！然后就是等待application 的回应。既然需要等待application的回复，为何不早点
				  把对client FIN 的ACK发出去呢？ 事实上TCP也是这么做的，收到对方的断开连接请求，立马
				  发ACK予以确认，client --> server 方向连接断开。
				3.1 如果 server端有数据需要发送，则继续发送一直到数据发送完毕，然后application 发close
				  消息给TCP，现在可以关闭连接，然后Server TCP 发FIN=1 断开 server -->client方向的连接。
				3.2 如果 server端没有数据发送，application回应close消息给TCP，现在可以关闭连接，然后
				  Server TCP 发FIN=1 断开 server -->client方向的连接。
				4 client收到FIN之后回复ACK，等待2MSL后CLOSED，server收到ACK之后，CLOSED
				    【完毕】  
					  
