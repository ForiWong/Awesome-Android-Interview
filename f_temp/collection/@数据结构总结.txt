1、一般用大O表示法来描述复杂度，它表示的是数据规模 n 对应的复杂度
◼ 忽略常数、系数、低阶
	9 >> O(1) 
	2n + 3 >> O(n) 
	n2 + 2n + 6 >> O(n2) 
	4n3 + 3n2 + 22n + 100 >> O(n3) 写法上，n3 等价于 n^3 ◼ 

注意：大O表示法仅仅是一种粗略的分析模型，是一种估算，能帮助我们短时间内了解一个算法的执行效率

复杂度对比：
O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2的n方)< O(n的阶层) < O(n的n次方)

2、算法的优化方向
◼ 用尽量少的存储空间
◼ 用尽量少的执行步骤（执行时间）
◼ 根据情况，可以
空间换时间
时间换空间

3、什么是数据结构？
◼ 数据结构是计算机存储、组织数据的方式
◼ 在实际应用中，根据使用场景来选择最合适的数据结构
线性结构：线性表（数组、链表、栈、队列、哈希表）
树形结构：二叉树、AVL树、红黑树、B树、堆、Trie、哈夫曼树、并查集
图形结构：邻接矩阵、领接表

数据结构是一个具有某些接口的存放数据的类。
不只有一种实现，可以有多个实现。

4、数组是一种顺序存储的线性表，所有元素的内存地址是连续的
 数组有个致命的缺点：无法动态修改容量。

5、所以有了动态数组ArrayList的类变量：
	size: 元素的数量
	elements[]:数组
	容量（默认容量）
	
6、ArrayList的特点
用arr数组（Object[]）构造的集合，是有序的，add元素可为null，可重复；

当第一次添加元素的时候，集合容量为10，当添加新元素超过了数组元素，则扩容（int newCapacity = oldCapacity + (oldCapacity >> 1)），容量扩为当前的1.5倍；

当删除元素的时候，需要将后续的元素移动；

clear方法没有删除元素，是将所有元素的值赋为null，将size赋值为0;
如：|for (int i = 0; i < size; i++)
            elementData[i] = null;
        size = 0;|

线程不安全，删除，在特定未知插入元素都比较低效。     

7、数组（固定大小） --> 添加功能自动扩容
--> 得到ArrayList
--> 但是ArrayList特定位置删除、插入比较慢
--> 并且，更大的问题：--> 在扩容的事由有个很大的问题，可能造成存储空间的浪费

◼ 能否用到多少就申请多少内存？链表可以办到这一点！

8、动态数组的缩容
如果内存使用比较紧张，动态数组有比较多的剩余空间，可以考虑进行缩容操作。
比如剩余空间占总容量的一半时，就进行缩容。

9、链式存储
节点node： 本身存储的数据 + 下一个节点的地址 
这样即用即申请空间，一点不浪费

链表的设计核心是Node节点 --> 造就了链式存储。
也是线性表，但是它在内存中所有元素不一定是连续的。
因为它是需要的时候，再分配内存所以必然是不连续的。

   LinkedList {  //链表
		size：大小
		first:第一个node的地址
	
		写个内部类Node {
			E element 元素
			Node next
		}
    }

10、应用：快慢指针的使用--判断链表是否有环。

11、链表在增、删的时候也是并没有很快。	那为什么网上说它很快呢？其实是只链表在增、删那一刻的操作比较快，实际上这步操作前面还需要查找的步骤。
其实：链表的优点在方便扩容、省内存。动态数组可能导致内存极大的浪费。
	
12、上面学的是单向链表。
双向链表：可以提升链表的整合性能
单向链表 VS 双向链表的复杂度：虽然复杂度是一样的,双向链表操作数量缩减了近一半。

13、双向链表 VS 动态数组
◼动态数组：开辟、销毁内存空间的次数相对较少，但可能造成内存空间浪费（可以通过缩容解决）
◼双向链表：开辟、销毁内存空间的次数相对较多，但不会造成内存空间的浪费

◼ 如果频繁在尾部进行添加、删除操作，动态数组、双向链表均可选择
◼ 如果频繁在头部进行添加、删除操作，建议选择使用双向链表
◼ 如果有频繁的（在任意位置）添加、删除操作，建议选择使用双向链表
◼ 如果有频繁的查询操作（随机访问操作），建议选择使用动态数组

14、java 官方的LinkedList源码分析,也是通过双向链表实现的。

15、栈stack，一端操作，有栈底，栈顶。LIFO后进先出。
在栈顶：入栈、出栈。

16、栈的实现：可以用arraylist或链表实现栈。
Java官方的也有栈是继承Vector的，和ArrayList很像的实现啦，但是Vector是线程安全的。

17、队列Queue：队尾、队头； 入队、出队。先进先出 FIFO。

18、队列的实现：使用双向链表实现。
看Java的队列Queue使用LinkedList链表实现队列。
还可以通过两个栈来实现。

19、前面的是单端队列，还有双端队列Deque: double ended queue。
能在头尾两端添加、删除的队列。
也可以使用LinkedList实现双端队列
Java官方也是这么做的。

20、二叉树概念 
节点、各种节点（根节点、父、子、兄弟节点）
空树
一颗树
子树、左、右子树
节点的度：子树的个数
树的度：所有节点度中的最大值
叶子节点：度为0的节点

21、二叉树 Binary Tree 有序树
每个节点的度最大为 2（最多拥有 2 棵子树）
左子树和右子树是有顺序的
即使某节点只有一棵子树，也要区分左右子树

22、二叉搜素树
比较接口 Comparable<E>
比较器Comparator
两者结合：比较器 + 比较接口
实际上，Java官方都有实现比较器、比较接口

23、二叉树的遍历：前序遍历，使用递归。
中序遍历，使用递归，二叉搜索树的中序遍历结果是升序或降序的。
后序遍历，使用递归。
层序遍历

24、AVL树 （平衡因子：左右子树的高度差）
AVL树的特点
每个节点的平衡因子只可能是 1、0、-1（绝对值 ≤ 1，如果超过 1，称之为“失衡”）
每个节点的左右子树高度差不超过 1 
搜索、添加、删除的时间复杂度是 O(logn)

二叉树<--二叉搜素树<--AVL树、红黑树

25、B树是一种平衡的多路搜索树，多用于文件系统、数据库的实现。
一个多叉树。
一棵m阶B树(balanced tree of order m)，B就是平衡的。
二叉树
二叉搜素树
AVL树：又叫平衡二叉搜索树(Self-balancing binary search tree)
红黑树（与 4阶B树 是逻辑等价的）
红黑树也是一种自平衡的二叉搜索树，其中一个作用也是为保证自平衡。

26、红黑树：元素（或节点）必须遵循某些规则，使得元素组成的数据结构，有搜索、添加、删除操作的时间复杂度达到最优。
在添加、删除的过程中，肯定会出现不满足规则的情况。
一定要注意，是在操作过程中要去恢复原则，也是在添加操作完成的时候，通过某些恢复操作就可以实现之后的结构还是符合红黑树的规则。
最终，目的是平衡查找、添加、删除的复杂度。

27、◼ 红黑树必须满足以下 5 条性质
	1. 节点是 RED 或者 BLACK
	2. 根节点是 BLACK
	3. 叶子节点（外部节点，空节点）都是 BLACK
	4. RED 节点的子节点都是 BLACK
	✓ RED 节点的 parent 都是 BLACK
	✓ 从根节点到叶子节点的所有路径上不能有 2 个连续的 RED 节点
	5. 从任一节点到叶子节点的所有路径都包含相同数目的 BLACK 节点
	
28、红黑树的平衡
◼ 相比AVL树，红黑树的平衡标准比较宽松：没有一条路径会大于其他路径的2倍 
◼ 是一种弱平衡、黑高度平衡
◼ 红黑树的最大高度是 2 ∗ log2(n + 1) ，依然是O(logn)级别

29、集合（set）
不存放重复的元素，常用于去重。
所以没必要有索引，也没有顺序。

30、集合的实现
可以使用动态数组
链表
二叉搜索树（AVL树、红黑树）来实现

用链表、红黑树实现set。
使用链表复杂度增删改 O(n)
使用红黑树O(logn)
数据规模上去之后，红黑树的性能强很多。
但是使用红黑树的局限性是 元素必须要有可比较性。
那么这个局限怎么解决呢？ 有限时候我们的元素可能不需要有比较性。 

31、映射Map
Map 在有些编程语言中也叫做字典（dictionary，比如 Python、Objective-C、Swift 等）.
Map 的每一个 key 是唯一的.

类似 Set，Map 可以直接利用之前学习的链表、二叉搜索树（AVL树、红黑树）等数据结构来实现。
之前的节点上只有元素，
现在用来存放映射，就是每个节点有key和value。

32、Map 的所有 key 组合在一起，其实就是一个 Set。
Set 可以间接利用 Map 来作内部实现
Java官方的TreeSet也是使用TreeMap实现

33、不考虑顺序、不考虑 Key 的可比较性，Map 有更好的实现方案，平均时间复杂度可以达到 O(1)，那就是采取哈希表来实现 Map
a. 利用哈希函数生成 key 对应的 index【O(1)】
b. 根据 index 操作定位数组元素【O(1)】 
	
哈希冲突（Hash Collision） 
◼ 哈希冲突也叫做哈希碰撞
2 个不同的 key，经过哈希函数计算出相同的结果
key1 ≠ key2 ，hash(key1) = hash(key2)

◼ 解决哈希冲突的常见方法
1. 开放定址法（Open Addressing） ✓ 按照一定规则向其他地址探测，直到遇到空桶
2. 再哈希法（Re-Hashing） ✓ 设计多个哈希函数
3. 链地址法（Separate Chaining） ✓ 比如通过链表将同一index的元素串起来

JDK1.8的哈希冲突解决方案
◼ 默认使用单向链表将元素串起来
◼ 在添加元素时，可能会由单向链表转为红黑树来存储元素
比如当哈希表容量 ≥ 64 且 单向链表的节点数量大于 8 时 

◼ 当红黑树节点数量少到一定程度时，又会转为单向链表

◼ JDK1.8中的哈希表是使用链表+红黑树解决哈希冲突
◼ 思考：这里为什么使用单链表？
每次都是从头节点开始遍历
单向链表比双向链表少一个指针，可以节省内存空间

34、LinkedHashMap
◼ 在HashMap的基础上维护元素的添加顺序，使得遍历的结果是遵从添加顺序的。
也就是说LinkedHashMap对于Hashmap而言，内存消耗更大了。

35、二叉堆
需求：设计一种数据结构，用来存放整数，要求提供3个接口
	添加元素
	获取最大值
	删除最大值

为了实现以上的需求，我们可以用动态数组、链表：即获取最大的需要比较所有元素一遍；
如果用有序的数组呢？就是需要在添加时做排序？
BBST 也是可以的。

36、二叉堆（Binary Heap） 
◼ 逻辑结构： 二叉堆的逻辑结构就是一棵完全二叉树，所以也叫完全二叉堆
◼ 物理结构（内存结构）： 鉴于完全二叉树的一些特性，二叉堆的底层（物理结构）一般用数组实现即可

37、Top K问题
◼ 从 n 个整数中，找出最大的前 k 个数（ k 远远小于 n ） 
◼ 方法一：如果使用排序算法进行全排序，需要 O(nlogn) 的时间复杂度
◼ 方法二：如果使用二叉堆来解决，可以使用 O(nlogk) 的时间复杂度来解决
新建一个小顶堆
扫描 n 个整数
		✓ 先将遍历到的前 k 个数放入堆中
		✓ 从第 k + 1 个数开始，如果大于堆顶元素，就使用 replace 操作（删除堆顶元素，将第 k + 1 个数添加到堆中）
扫描完毕后，堆中剩下的就是最大的前 k 个数

◼ 如果是找出最小的前 k 个数呢？
用大顶堆
如果小于堆顶元素，就使用 replace 操作

38、优先级队列（Priority Queue）
◼ 普通的队列是 FIFO 原则，也就是先进先出
◼ 优先级队列则是按照优先级高低进行出队，比如将优先级最高的元素作为对头优先出队。

优先队列的底层实现
◼ 根据优先队列的特点，很容易想到：可以直接利用二叉堆作为优先队列的底层实现
◼ 可以通过 Comparator 或 Comparable 去自定义优先级高低

Java官方java.util.PriorityQueue 使用的二叉堆， 最小堆。

