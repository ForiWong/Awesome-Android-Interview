## 参考 https://www2.jianshu.com/p/bd3d673aa979
# 1. 移动设备元件耗电大户有哪些：
  屏幕显示
  蜂窝、数据
  CPU
  WiFi
  音频
  蓝牙
  GPS
  相机
  重力感应等等

# 2、屏幕
屏幕是耗电最大元件之一，但是用户要和app交互就要点亮屏幕，有人可能会觉得屏幕的明暗是用户自己根据喜好设定的，我们无可奈何。
其实不然，在有些时候是可以通过UI的设计来减少屏幕电能消耗的。
优化方案：较暗的颜色比明亮的颜色更节能，所以在很多留白的地方可以考虑使用偏暗的色调，当然这要在不影响用户体验的前提下。

# 3、无线网络
无线网络主要是WIFI和移动运营商网络，通常情况下使用移动网络要比WIFI耗电要多一些。

网络优化方案：

减少网络高功率保持时间：
1）文本和文件压缩传输。
不管发送还是请求数据，在数据传输过程中使用gzip将数据进行压缩。经过压缩的数据需要更短的时间传输即可完成，
这样是无线所处的高功率状态时间更短，从而减少了耗电。
2）精简文本文件。

所谓精简就是去掉文本中空行、空格、注释等无意义内容。
①请求一个图片时，客户端提供一个分辨率大小，服务器根据分辨率把裁剪缩放后的图片给客户端返回。也可以使用Android
端使用Bitmap.Option自行获取缩放的图片
②使用webp图片。

减少网络请求次数
1.使用缓存。
把经常使用的文件缓存到本地，如头像icon、好友信息等。以后很多时间都可以直接从本地读取缓存减少网络请求次数。
2.移动网络下最好批量执行网络请求，利用一次高功率状态执行尽可能多的事情，从而减少频繁间隔请求导致状态转换消耗更多电量。

# 4、CPU
浮点运算比整数运算相对更消耗cpu时间片，相应耗电也就增加，因而在编码过程尽量减少浮点运算，例如使用位移代替除法。

避免wakelock不正确使用：wakelock可以唤醒设备也可以阻止设备休眠。在PowerManager类中谷歌已经声明了：这个类会影响设备
电量，除非必须，否则尽量不要使用该类，同时使用完毕要尽快释放。wankelock有几种类型，在使用时注意选择正确地类型。

使用JobScheduler：
很多时候为了满足我们的需求而没有考虑cpu的感受，为了执行1s中的数据区唤醒cpu，但实际却消耗了约两分钟的电量。为此谷歌在
5.0系统下提供了JobScheduler组件，使用场景：

必要不紧急，可延迟执行的任务，比如数据块更新，bug日志上报。

耗电大德任务，如备份在充电时执行。

# 5、其他优化
每个传感器都有最大信号频率，开发者在使用传感器时要设置合适的采样频率。最后在使用完成后一定要进行注销，
否则激活的传感器会一直进行检测，造成cpu负载和电量消耗。


## 2.App电量优化
(1)怎么做电量测试？
电量相关的测试相对来说难度较大，因为 App 在具体手机上的耗电量无法准确统计，每一个手机所使用的硬件不一样，
那么它相应的功耗就不一样。而且这个功耗值我们只能在线下通过导出手机的 power_profile.xml 文件拿到。
由于我们无法获取准确的耗电量，所以我们只能增加多个维度来辅助判断 App 是否耗电。
最后，我们可以分场景各个突破。

关于电量测试，我们可以针对各个功能场景进行针对性的专项测试。操作一段时间后，我们可以在手机设置—电量消
耗里面，利用其数据作为判断依据。这样虽然直观，但精确度不行。

#介绍 Battery Historian：

- Google 推出的一款 Android 电量分析工具，它支持 Android 5.0 及以上系统的电量分析。
- 它获取到的各个耗电模块的耗电信息要相对精确、丰富地多。例如 GPS、WaleLock、蓝牙 等的工作时间以及耗电量。
- 此外，它不仅可以针对单个 App 进行选择，也可以比对不同的电量场景的信息，比如 优化前、优化后 的信息。

- Battery Historian 的缺点在于它只能在线下使用。因此除了使用其在线下测试之外，我们还需要在线上增加一些
  电量的辅助监控，统计例如：耗电组件的使用次数、调用堆栈以及访问时间。这些都是与用户相关的基础电量消耗数据，
  如果有用户反馈，我们就可以通过这些信息来判断用户是不是有耗电的操作。


(2)有哪些有效的电量优化手段？
因为我们不能在线上统计出 App 的电量消耗，因此需要在尽量保证 App 在正常使用下的耗电。对此我们采取了一系列的电量优化措施：
1）、网络相关
- 网络请求的时机以及次数，将可以延迟的网络请求批量发送，减少网络被激活的时机与次数。
- 此外，我们可以对网络传输数据进行压缩，以降低传输的时间与流量。
- 最后，一定要禁止使用轮询的方式来做业务操作。

2）、传感器相关
根据场景谨慎地选择传感器使用的模式，比如说在使用 GPS 的时候一般要避免使用高精度的模式，或者是尽量复用上一次的定位结果。

3）、WakeLock【唤醒锁】
我们在实际项目中使用 WakeLock 有几个注意事项，
第一，acquire、release 要成对地释放，
第二，尽量使用 acquire 的超时方法来设置超时时间，避免因为异常情况从而导致 WakeLock 而无法释放的情况，
第三，关于 WakeLock 的释放一定要写在 try-catch-finally 的 finally 当中，保证 WakeLock 在异常情况下的释放。

4）、JobScheduler【后台任务调度】
JobScheduler 可以允许开发者在符合某些条件下创造执行在后台的任务，我们可以设置执行一些耗电操作的场景，
比如说 处于 WIFI 状态下同时连接电源 的情况下。同时，要注意用户在离开界面后，要避免耗电的操作，比如说停止播放动画。
通过这些操作，我们的 App 就不会比之前耗电了。

介绍：
JobScheduler主要用于在未来某个时间下满足一定条件时触发执行某项任务的情况，涉及的条件可以是网络、电量、时间等，
例如执行特定的网络、是否只在充电时执行任务等。
Android后台调度机制有多种选择，其中对于在指定特定场景下而触发的任务，那么JobScheduler便是较佳选择；JobScheduler
主要用于在未来某个时间、对满足一定条件时触发某项任务。

#（3） 后台任务的总体指导思想是减少、延迟和合并。
让应用变得“偷懒至上”是指设法减少和优化特别耗电的操作。“偷懒至上”设计背后的核心问题包括：

减少操作：您的应用是否存在可删减的多余操作？例如，是否可以缓存已下载的数据，而不是反复唤醒无线装置来重新下载数据？
推迟操作：应用是否需要立即执行某项操作？例如，是否可以等到设备充电后再将数据备份到云端？
合并操作：工作是否可以批处理，而不是多次将设备置于活动状态？例如，是否真的有必要让数十个应用分别在不同时间打开无线装置发送消息？是否可以改为在无线装置单次唤醒期间传输消息？
在使用 CPU、无线装置和屏幕时，您应该考虑这些问题。“偷懒至上”设计通常可以很好地优化这些耗电因素。


# 3.Android中的WakeLock
（1）两个处理器
1）Application Processor (AP):
AP是ARM架构的处理器，用于运行Linux+Android系统。
2）Baseband Processpr (BP):
BP用于运行实时操作系统(RTOS)，运行手机射频通信控制软件。

- 非通话时间BP能耗很低；而AP由于需要运行操作系统、用户界面和应用程序，只要处于非休眠状态能耗相对BP要高出很多，
  执行图形运算会更高。

# 让系统保持“清醒”
当手机灭屏状态下保持一段时间后，系统会进入休眠，一些后台任务比如网络下载，播放音乐会得不到正常的执行。
WakeLock API可以确保应用程序中关键代码的正确执行，使应用程序有能力控制AP的休眠状态。

# 一种锁机制
当应用申请了WakeLock,WakeLock会阻止AP挂起，系统无法进入休眠，即使在灭屏的状态下，应用要执行的任务依然
不会被打断。当所有WakeLock被释放（解锁/超时），系统会挂起启动休眠机制进入休眠。

使用WakeLock
# 权限
<!--WakeLock需要的权限-->
<uses-permission android:name="android.permission.WAKE_LOCK"/>

# 代码
PowerManager pm= (PowerManager) this.getSystemService(Context.POWER_SERVICE);
PowerManager.WakeLock wakeLock=pm.newWakeLock(PowerManager.ON_AFTER_RELEASE|PowerManager.PARTIAL_WAKE_LOCK,"Tag");
//申请WakeLock
wakeLock.acquire();

//... do work...

//释放wakeLock
//当使用wakeLock.acquire(timeout)的方式时系统会自动释放
wakeLock.release();

