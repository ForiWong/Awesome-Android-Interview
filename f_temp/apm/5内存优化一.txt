1、Java 内存分配模型
JVM 将整个内存划分为了几块，分别如下所示：
1）、方法区：存储类信息、常量、静态变量等。=> 所有线程共享
2）、虚拟机栈：存储局部变量表、操作数栈等。
3）、本地方法栈：不同与虚拟机栈为 Java 方法服务、它是为 Native 方法服务的。
4）、堆：内存最大的区域，每一个对象实际分配内存都是在堆上进行分配的，而在虚拟机栈中分配的只是引用，这些引用会指向堆中真正存储的对象。此外，堆也是垃圾回收器（GC）所主要作用的区域，并且，内存泄漏也都是发生在这个区域。=> 所有线程共享
5）、程序计数器：存储当前线程执行目标方法执行到了第几行。

2、GC算法
1）、标记-清除算法
实现原理：
标记出所有需要回收的对象。
统一回收所有被标记的对象。

特点：
标记和清除效率不高。
产生大量不连续的内存碎片。

2）、复制算法
实现原理：
将内存划分为大小相等的两块。
一块内存用完之后复制存活对象至另一块。
清理另一块内存。

特点：
实现简单，运行高效。
浪费一半空间，代价大。

3）、标记-整理算法
实现原理：
标记过程与 ”标记-清除“ 算法一样。
存活对象往一端进行移动。
清理其余内存。

特点：
避免 ”标记-清除” 算法导致的内存碎片。
避免复制算法的空间浪费。

4）、分代收集算法（大多数虚拟机厂商所选用的算法）
特点：
结合多种收集算法的优势。
新生代对象存活率低 => “复制” 算法（注意这里每一次的复制比例都是可以调整的，如一次仅复制 30% 的存活对象）。
老年代对象存活率高 => “标记-整理” 算法。

3、避免内存泄漏
定义：Android系统虚拟机的垃圾回收是通过虚拟机GC机制来实现的。GC会选择一些还存活的对象作为内存遍历的根节点GC Roots，通过对GC Roots的可达性来判断是否需要回收。内存泄漏就是在当前应用周期内不再使用的对象被GC Roots引用，导致不能回收，使实际可使用内存变小。

使用MAT来查找内存泄漏。

4、常见内存泄漏场景
对于内存泄漏，其本质可理解为无法回收无用的对象。

1、资源性对象未关闭
对于资源性对象不再使用时，应该立即调用它的close()函数，将其关闭，然后再置为null。例如Bitmap等资源未关闭会造成内存泄漏，此时我们应该在Activity销毁时及时关闭。

2、注册对象未注销
例如BraodcastReceiver、EventBus未注销造成的内存泄漏，我们应该在Activity销毁时及时注销。

3、类的静态变量持有大数据对象
尽量避免使用静态变量存储数据，特别是大数据对象，建议使用数据库存储。

4、单例造成的内存泄漏
优先使用Application的Context，如需使用Activity的Context，可以在传入Context时使用弱引用进行封装，然后，在使用到的地方从弱引用中获取Context，如果获取不到，则直接return即可。

5、非静态内部类的静态实例
该实例的生命周期和应用一样长，这就导致该静态实例一直持有该Activity的引用，Activity的内存资源不能正常回收。此时，我们可以将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，尽量使用Application Context，如果需要使用Activity Context，就记得用完后置空让GC可以回收，否则还是会内存泄漏。

6、Handler临时性内存泄漏
1）使用一个静态Handler内部类，然后对Handler持有的对象（一般是Activity）使用弱引用，这样在回收时，也可以回收Handler持有的对象。
2）在Activity的Destroy或者Stop时，应该移除消息队列中的消息，避免Looper线程的消息队列中有待处理的消息需要处理。

7、容器中的对象没清理造成的内存泄漏
在退出程序之前，将集合里的东西clear，然后置为null，再退出程序。

8、WebView
WebView都存在内存泄漏的问题，在应用中只要使用一次WebView，内存就不会被释放掉。我们可以为WebView开启一个独立的进程，使用AIDL与应用的主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，达到正常释放内存的目的。

9、使用ListView时造成的内存泄漏
在构造Adapter时，使用缓存的convertView。

5、对象引用
从Java 1.2版本开始引入了三种对象引用方式：SoftReference、WeakReference 和 PhantomReference 三个引用类，引用类的主要功能就是能够引用但仍可以被垃圾回收器回收的对象。在引入引用类之前，只能使用Strong Reference，如果没有指定对象引用类型，默认是强引用。

1）强引用
如果一个对象具有强引用，GC就绝对不会回收它。当内存空间不足时，JVM会抛出OOM错误。

2）软引用
如果一个对象只具有软引用，则内存空间足够，GC时就不会回收它；如果内存不足，就会回收这些对象的内存。可用来实现内存敏感的高速缓存。
软引用可以和一个ReferenceQueue（引用队列）联合使用，如果软引用引用的对象被垃圾回收器回收，JVM会把这个软引用加入与之关联的引用队列中。

3）弱引用
在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
这里要注意，可能需要运行多次GC，才能找到并释放弱引用对象。

4）虚引用
只能用于跟踪即将对被引用对象进行的收集。虚拟机必须与ReferenceQueue类联合使用。因为它能够充当通知机制。


6、减小不必要的内存开销
1）AutoBoxing，int比Integer内存占用小。
2）内存复用
资源复用：通用的字符串、颜色定义、简单页面布局的复用。
视图复用：可以使用ViewHolder实现ConvertView复用。
对象池：显示创建对象池，实现复用逻辑，对相同的类型数据使用同一块内存空间。
Bitmap对象的复用：使用inBitmap属性可以告知Bitmap解码器尝试使用已经存在的内存区域，新解码的bitmap会尝试使用之前那张bitmap在heap中占据的pixel data内存区域。

3）HashMap与ArrayMap

4）使用 IntDef和StringDef 替代枚举类型

5）LruCache 最近最少使用淘汰机制缓存。

6）图片内存优化

7）图片放置优化
只需要UI提供一套高分辨率的图，图片建议放在drawable-xxhdpi文件夹下，这样在低分辨率设备中图片的大小只是压缩，不会存在内存增大的情况。如若遇到不需缩放的文件，放在drawable-nodpi文件夹下。

8）在App可用内存过低时主动释放内存。在App退到后台内存紧张即将被Kill掉时选择重写 onTrimMemory/onLowMemory 方法去释放掉图片缓存、静态缓存来自保。

9）item被回收不可见时释放掉对图片的引用
ListView：因此每次item被回收后再次利用都会重新绑定数据，只需在ImageView onDetachFromWindow的时候释放掉图片引用即可。
RecyclerView：因为被回收不可见时第一选择是放进mCacheView中，这里item被复用并不会只需bindViewHolder来重新绑定数据，只有被回收进mRecyclePool中后拿出来复用才会重新绑定数据，因此重写Recycler.Adapter中的onViewRecycled()方法来使item被回收进RecyclePool的时候去释放图片引用。

10）避免创作不必要的对象
例如，我们可以在字符串拼接的时候使用StringBuffer（线程安全），StringBuilder。

11）自定义View中的内存优化
例如，在onDraw方法里面不要执行对象的创建，一般来说，都应该在自定义View的构造器中创建对象。

12）其它的内存优化注意事项
除了上面的一些内存优化点之外，这里还有一些内存优化的点我们需要注意，如下所示：
尽使用static final 优化成员变量。
使用增强型for循环语法。
在没有特殊原因的情况下，尽量使用基本数据类型来代替封装数据类型，int比Integer要更加有效，其它数据类型也是一样。
在合适的时候适当采用软引用和弱引用。
采用内存缓存和磁盘缓存。
尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏。

7、图片管理模块的设计与实现
1）实现异步加载功能，实现网络图片显示
2）实现三级缓存：内存--本地--网络
