1、所谓黑色保活，就是利用不同的app进程使用广播来进行相互唤醒。
比如，利用系统产生的广播唤醒app（已经被Google取消）;接入第三方SDK也会唤醒相应的app进程（还有用）。

2、白色保活手段非常简单，就是调用系统api启动一个前台的Service进程，这样会在系统的通知栏生成一个Notification，用来让用户知道有这样一个app在运行着，哪怕当前的app退到了后台。常见比如，一些音乐播放器。

3、灰色保活，这种保活手段是应用范围最广泛。它是利用系统的漏洞来启动一个前台的Service进程，与普通的启动方式区别在于，它不会在系统通知栏处出现一个Notification，看起来就如同运行着一个后台Service进程一样。这样做带来的好处就是，用户无法察觉到你运行着一个前台进程（因为看不到Notification）,但你的进程优先级又是高于普通后台进程的。那么如何利用系统的漏洞呢，大致的实现思路和代码如下：
思路一：API < 18，启动前台Service时直接传入new Notification()；
思路二：API >=18，同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理。
使用灰色保活并不代表着你的Service就永生不死了，只能说是提高了进程的优先级。

4、什么是oom_adj？它是linux内核分配给每个系统进程的一个值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收。
进程的oom_adj越大，表示此进程优先级越低，越容易被杀回收；越小，表示进程优先级越高，越不容易被杀回收。普通app进程的oom_adj>=0,系统进程的oom_adj才可能<0。
根据进程的重要性，可以划分为5级：
 前台进程 (Foreground process)
 可见进程 (Visible process)
 服务进程 (Service process)
 后台进程 (Background process)
 空进程 (Empty process)
—————————————————————————————————
华为的机子上发现微信和手Q的UI进程退到后台，oom_adj的值一点都没有变，因为微信在华为机子的白名单中。

5、可以在监控到APP跳到后台的时候，创建一个空转的service，
然后，在service被destroy时，继续另开一个service。


