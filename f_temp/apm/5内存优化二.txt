1、内存问题可以细分为如下三类:内存抖动、内存泄漏、内存溢出。
1）内存抖动
内存波动图形呈锯齿张、GC导致卡顿。这个问题在Dalvik虚拟机上会更加明显，而ART虚拟机在内存管理跟回收策略上都做了大量优化，内存分配和GC效率相比提升了5~10倍，所以 出现内存抖动的概率会小很多。

2）内存泄漏
Android系统虚拟机的垃圾回收是通过虚拟机GC机制来实现的。GC会选择一些还存活的对象作为内存遍历的根节点GC Roots，通过对GC Roots的可达性来判断是否需要回收。内存泄漏就是在当前应用周期内不再使用的对象被GC Roots引用，导致不能回收，使实际可使用内存变小。

3）内存溢出
即OOM，OOM时会导致程序异常。Android设备出厂以后，java虚拟机对单个应用的最大内存分配就确定下来了，超出这个值就会OOM。
除了因内存泄漏累积到一定程度导致OOM的情况以外，也有一次性申请很多内存，比如说一次创建大的数组或者是载入大的文件如图片的时候会导致OOM。而且，实际情况下 很多OOM就是因图片处理不当而产生的。

2、内存检测工具：Memory Profiler；
LeakCanary自动化 内存泄漏检测神器。

3、Java 内存分配
Java的内存分配区域分为如下五部分：
1）、方法区：主要存放静态常量。
2）、虚拟机栈：Java变量引用。
3）、本地方法栈：native变量引用。
4）、堆：对象。
5）、程序计数器：计算当前线程的当前方法执行到多少行。

4、Java内存回收算法
（1）标记-清除算法
流程可简述为两步：
1）、标记所有需要回收的对象。
2）、统一回收所有被标记的对象。

优点：
实现比较简单。

缺点：
1）、标记、清除效率不高。
2）、产生大量内存碎片。

（2）复制算法
流程可简述为 三步：
1）、将内存划分为大小相等的两块。
2）、一块内存用完之后复制存活对象到另一块。
3）、清理另一块内存。
##这里的话，是不是重在查询、复制，清除操作是很高效的。

优点
实现简单，运行高效，每次仅需遍历标记一半的内存区域。
缺点
会浪费一半的空间，代价大。

（3）标记-整理算法
流程可简述为 三步：
1）、标记过程与 标记-清除算法 一样。
2）、存活对象往一端进行移动。
3）、清理其余内存。
##这个相对于复制算法有什么区别呢？是不是并发GC呢？在移动的过程，不能进行分配内存。
优点
1）、避免 标记-清除 导致的内存碎片。
2）、避免复制算法的空间浪费。

（4）分代收集算法
现在主流的虚拟机 一般用的比较多的还是分代收集算法，它具有如下 特点：
1）、结合多种算法优势。
2）、新生代对象存活率低，使用 复制算法。
3）、老年代对象存活率高，使用 标记-整理算法。

5、内存抖动
当内存频繁分配和回收导致内存不稳定，就会出现内存抖动，它通常表现为频繁GC、内存曲线呈锯齿状。并且，它的危害也很严重，通常会导致页面卡顿，甚至造成OOM。

为什么内存抖动会导致 OOM？主要原因有如下两点：
1）、频繁创建对象，导致内存不足及碎片（不连续）。
2）、不连续的内存片无法被分配，导致OOM。

排查方法：通常的技巧就是着重查看循环或频繁被调用的地方。

面列举一些导致内存抖动的常见案例，如下所示：
（1）字符串使用加号拼接
1）、使用StringBuilder替代。
2）、初始化时设置容量，减少StringBuilder的扩容。

（2）资源复用
1）、使用 全局缓存池，以 重用频繁申请和释放的对象。
2）、注意 结束 使用后，需要 手动释放对象池中的对象。

（3）减少不合理的对象创建
1）、ondraw、getView 中创建的对象尽量进行复用。
2）、避免在循环中不断创建局部变量。

（4）使用合理的数据结构
使用 SparseArray类族、ArrayMap 来替代 HashMap。


6、内存问题总结
1、内类是有危险的编码方式
每个类实例都具有一个 this$0，当它的内类需要访问它的成员时，内类就会持有外类的 this$0，通过 this$0 就可以访问外部类所有的成员。
解决方案是在 Activity 关闭，即触发 onDestory 时解除内类和外部的引用关系。

2、普通 Hanlder 内部类的问题
这也是一个 this$0 间接引用的问题，对于 Handler 的解决方案一般可以归结为如下三个步骤：
static +  WeakReference;
 removeCallbackAndMessages 来移除回调和消息。

3、登录界面的内存问题
如果在闪屏页跳转到登录界面时没有调用 finish()，则会造成闪屏页的内存泄漏，在碰到这种”过渡界面“的情况时，需要注意不要产生这样的内存 Bug。

4、使用系统服务时产生的内存问题
我们通常都会使用 getSystemService 方法来获取系统服务，但是当在 Activity 中调用时，会默认把 Activity 的 Context 传给系统服务，在某些不确定的情况下，某些系统服务内部会产生异常，从而 hold 住外界传入的 Context。
解决方案是 直接使用 Applicaiton 的 Context 去获取系统服务。

5、把 WebView 类型的泄漏装进垃圾桶进程
我们都知道，对应 WebView 来说，其 网络延时、引擎 Session 管理、Cookies 管理、引擎内核线程、HTML5调用系统声音、视频播放组件等产生的引用链条无法及时打断，造成的内存问题基本上可以用”无解“来形容。
解决方案是我们可以 把 WebView 装入另一个进程。 具体为在 AndroidManifes 中对当前的 Activity 设置 android:process 属性即可，最后，在 Activity 的 onDestory 中退出进程，这样即可基本上终结 WebView 造成的泄漏。

6、在适当的时候对组件进行注销
我们在平常开发过程中经常需要在Activity创建的时候去注册一些组件，如广播、定时器、事件总线等等。这个时候我们应该在适当的时候对组件进行注销，如 onPause 或 onDestory 方法中。

7、Handler / FrameLayout 的 postDelyed 方法触发的内存问题
不仅在使用 Handler 的 sendMessage 方法时，我们需要在 onDestory 中使用 removeCallbackAndMessage 移除回调和消息，在使用到 Handler / FrameLayout 的 postDelyed 方法时，我们需要调用 removeCallbacks 去移除实现控件内部的延时器对 Runnable 内类的持有。

8、图片放错资源目录也会有内存问题
在做资源适配的时候，因为需要考虑到 APK 的瘦身问题，无法为每张图片在每个 drawable / mipmap 目录下安置一张适配图片的副本。如果放到分辨率低的目录如 hdpi 目录，则可能会造成内存问题，这个时候建议尽量问设计人员要高品质图片然后往高密度目录下方，如 xxhdpi 目录，这样 在低密屏上”放大倍数“是小于1的，在保证画质的前提下，内存也是可控的。也可以使用 Drawable.createFromSream 替换 getResources().getDrawable 来加载，这样便可以绕过 Android 的默认适配规则。

9、列表 item 被回收时注意释放图片的引用

10、使用 ViewStub 进行占位
我们应该使用 ViewStub 对那些没有马上用到的资源去做延迟加载，并且还有很多大概率不会出现的 View更要去做懒加载，这样可以等到要使用时再去为它们分配相应的内存。

11、注意定时清理 App 过时的埋点数据
产品或者运营为了统计数据会在每个版本中不断地增加新的埋点。所以我们需要定期地去清理一些过时的埋点，以此来适当地优化内存以及CPU的压力。

12、针对匿名内部类 Runnable 造成内存泄漏的处理


7、搭建一套成体系化的图片优化/监控机制
1）统一图片库
在项目中，我们需要收拢图片的调用，避免使用 Bitmap.createBitmap、BitmapFactory 相关的接口创建 Bitmap，而应该使用自己的图片框架。

2）设备分级优化策略
内存优化首先需要根据设备环境来综合考虑，让高端设备使用更多的内存，做到 针对设备性能的好坏使用不同的内存分配和回收策略。
可以使用类似 device-year-class 的策略对设备进行分级。

3）建立统一的缓存管理组件
建立统一的缓存管理组件（参考 ACache），并合理使用 OnTrimMemory / LowMemory 回调，根据系统不同的状态去释放相应的缓存与内存。

4）低端机避免使用多进程

5）线下大图片检测
在开发过程中，如果检测到不合规的图片使用（如图片宽度超过View的宽度甚至屏幕宽度），应该立刻提示图片所在的Activity和堆栈，让开发人员更快发现并解决问题。

8、图片加载时的降级处理
使用 Glide、Fresco 等图片加载库，通过定制，在加载 bitmap 时，若发生 OOM，则使用 try catch 将其捕获，然后清除图片 cache，尝试降低 bitmap format（ARGB8888、RGB565、ARGB4444、ALPHA8）。
需要注意的是，OOM 是可以捕获的，只要 OOM 是由 try 语句中的对象声明所导致的，那么在 catch 语句中，是可以释放掉这些对象，解决 OOM 的问题的。

压缩
