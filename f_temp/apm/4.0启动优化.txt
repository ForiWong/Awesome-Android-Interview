1、思路：首先了解冷启动的流程；
	找到可控的阶段，即优化的方向；
	通过工具分析优化优先级、瓶颈；
	相对应的策略。
	
2、应用启动的类型总共分为如下三种：冷启动、热启动、温启动。
（1）冷启动：从点击应用图标到UI界面完全显示且用户可操作的全部过程。
特点：耗时最多，衡量标准。
启动流程：
Click Event -> IPC -> Process.start -> ActivityThread -> bindApplication -> LifeCycle -> ViewRootImpl
注释：先是进程创建 ——> ActivityThread线程创建（Looper、Handler） ——> 创建Application ——> Activity 生命周期——> ViewRootImpl绘制页面
（2）热启动
直接从后台切换到前台。
onResume-> 
特点：启动速度最快。
（3）温启动
只会重走Activity的生命周期，而不会重走进程的创建、Application的创建与生命周期等。
特点：较快，介于冷启动和热启动之间的一个速度。
启动流程：onCreate->onStart->onResume->ViewRootImpl

3、分析：优化方向是 Application和Activity的生命周期 这个阶段，因为这个阶段的时机对于我们来说是可控的，还有预览窗口。

4、启动耗时检测
最好的检测组合：“Systrace + 函数插桩”
（1）“函数插桩”：通过耗时统计工具，在需要的地方进行打点获取系统时间，就可以获取某段时间的耗时。
特点：精确，可带到线上，但是代码有侵入性，修改成本高。

（2）切面编程，利用AOP(Aspect Oriented Programming)打点
面向切面编程，通过预编译和运行期动态代理实现程序功能统一维护的一种技术，AspectJx 库。
特点：无侵入性；修改方便，建议使用。

（3）启动速度分析工具 — TraceView
使用方式：代码中添加：Debug.startMethodTracing()、检测方法、Debug.stopMethodTracing()。（需要使用adb pull将生成的.trace文件导出到电脑，然后使用Android Studio的Profiler进行加载）。
查看时间轴发布，找到耗时的瓶颈。

（4）启动速度分析工具 — Systrace
使用方式：代码插桩。首先，我们可以定义一个Trace静态工厂类，将Trace.begainSection()，Trace.endSection()封装成i、o方法，然后再在想要分析的方法前后进行插桩即可。
特点：结合Android内核的数据，生成Html报告。
系统版本越高，Android Framework中添加的系统可用Label就越多，能够支持和分析的系统模块也就越多。
必须手动缩小范围，会帮助你加速收敛问题的分析过程，进而快速地定位和解决问题。

5、评估的指标：使用什么指标来衡量启动速度的快慢？
平均启动时间的问题，一些体验很差的用户很可能被平均了。
建议的指标：
1）快开慢开比
如2s快开比，5s慢开比，可以看到有多少比例的用户体验好，多少比例的用户比较糟糕。
2）90%用户的启动时间
如果90%用户的启动时间都小于5s，那么90%区间的启动耗时就是5s。
启动的类型有哪几种？
首次安装启动
覆盖安装启动
冷启动（指标）
热启动（反映程序的活跃或保活能力）

6、主题切换：预览窗口优化
使用Activity的windowBackground主题属性预先设置一个启动图片（layer-list实现），在启动后，在Activity的onCreate()方法中的super.onCreate()前再setTheme(R.style.AppTheme)。

7、第三方库懒加载
按需初始化，特别是针对于一些应用启动时不需要初始化的库，可以等到用时才进行加载。

8、线程调度原理
1）任意时刻，只有一个线程占用CPU，处于运行状态。
2）多线程并发，轮流获取CPU使用权。
3）JVM负责线程调度，按照特定机制分配CPU使用权。

如何干预线程调度？设置线程优先级。

9、Android异步方式
1、Thread
最简单、常见的异步方式。
不易复用，频繁创建及销毁开销大。
复杂场景不易使用。

2、HandlerThread
自带消息循环的线程。
串行执行。
长时间运行，不断从队列中获取任务。

3、IntentService
继承自Service在内部创建HandlerThread。
异步，不占用主线程。
优先级较高，不易被系统Kill。

4、AsyncTask
Android提供的工具类。
无需自己处理线程切换。
需注意版本不一致问题（API 14以上解决）

5、线程池
Java提供的线程池。
易复用，减少频繁创建、销毁的时间。
功能强大，如定时、任务队列、并发数控制等。

6、RxJava
由强大的调度器Scheduler集合提供。
不同类型的Scheduler：
IO
Computation

7、异步方式总结
推荐度：从后往前排列。
正确场景选择正确的方式。

10、Android线程优化实战
线程使用准则：
1、严禁使用new Thread方式。
2、提供基础线程池供各个业务线使用，避免各个业务线各自维护一套线程池，导致线程数过多。
3、根据任务类型选择合适的异步方式：优先级低，长时间执行，HandlerThread；定时执行耗时任务，线程池。
4、创建线程必须命名，以方便定位线程归属，在运行期 Thread.currentThread().setName 修改名字。
5、关键异步任务监控，注意异步不等于不耗时，建议使用AOP的方式来做监控。
6、重视优先级设置（根据任务具体情况），Process.setThreadPriority() 可以设置多次。

11、锁定线程创建背景
项目变大之后收敛线程。项目源码、三方库、aar中都有线程的创建。
线程收敛，就是对所有的线程进行管理。不管是自己业务线的，还是引入第三方库的。

12、异步初始化
子线程分担主线程任务，并行减少时间。
1）耗时任务异化化。但是要注意，子线程不能阻塞主线程。
2）线程池管理线程，控制线程的数量。线程数量太多会相互竞争 CPU 资源，导致分给主线程的时间片减少，从而导致启动速度变慢。
3）避免主线程与子线程之间的锁阻塞等待，特别是防止主线程出现长时间的空转。
4）设置子线程优先级。不重要任务，设置子线程优先级为 THREAD_PRIORITY_BACKGROUND，这样子线程最多能获取到10%的时间片，优先保证主线程执行。
注释：麻烦，有些三方库之间可能出现相互依赖的。

13、延迟初始化

14、类预加载优化
在Application中提前异步加载初始化耗时较长的类。
如何找到耗时较长的类？替换系统的ClassLoader，打印类加载的时间，按需选取需要异步加载的类。
注意：
Class.forName()只加载类本身及其静态变量的引用类。
new 类实例 可以额外加载类成员变量的引用类。

15、WebView启动优化
1、WebView首次创建比较耗时，需要预先创建WebView提前将其内核初始化。
2、使用WebView缓存池，用到WebView的时候都从缓存池中拿，注意内存泄漏问题。
3、本地离线包，即预置静态页面资源。

16、页面数据预加载
在主页空闲时，将其它页面的数据加载好保存到内存或数据库，等到打开该页面时，判断已经预加载过，就直接从内存或数据库取数据并显示。

17、启动阶段不启动子进程
子进程会共享CPU资源，导致主进程CPU紧张。此外，在多进程情况下一定要可以在onCreate中去区分进程做一些初始化工作。
注意启动顺序：App onCreate之前是ContentProvider初始化。

18、闪屏页与主页的布局优化
1、布局优化。
2、过渡绘制优化。
布局越复杂，测量布局绘制的时间就越长。主要做到以下几点：
布局的层级越少，加载速度越快。
一个控件的属性越少，解析越快，删除控件中的无用属性。
使用<ViewStub/>标签加载一些不常用的布局，做到使用时在加载。
使用<merge/>标签减少布局的嵌套层次。
尽可能少用wrap_content，wrap_content会增加布局measure时的计算成本，已知宽高为固定值时，不用wrap_content。

19、启动优化黑科技
1）启动阶段抑制GC
启动时CG抑制，允许堆一直增长，直到手动或OOM停止GC抑制。（空间换时间）
缺点：需要白名单覆盖所有设备，但维护成本高。
2）保活啦，不被杀死，就容易启动了呗。

